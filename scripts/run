#!/usr/bin/env bash

set -o pipefail

# import common util functions
# utils are logging output helpers and 
# a function to check if required tools are installed
source scripts/util.sh

cmd=""
declare -r -a required_tools=( go )

usage() {
  echo "usage: $0 [-h|--help] COMMAND"
  echo "[-h|--help]      print this help text"
  echo "COMMAND         one of: local, tests"
}

parse_opts() {
  while getopts "h:-:" OPT; do
    if [ "$OPT" = "-" ]; then   # long option: reformulate OPT and OPTARG
      OPT="${OPTARG%%=*}"       # extract long option name
      OPTARG="${OPTARG#$OPT}"   # extract long option argument (may be empty)
      OPTARG="${OPTARG#=}"      # if long option argument, remove assigning `=`
    fi
    case "$OPT" in
      h | help) usage; exit 0 ;;
      *) { log_err "received invalid option"; usage; return 1; }
    esac
  done
  shift $((OPTIND - 1));

  # process positional args
  cmd="$1"
}

run_tests() {
    log_info "running tests..."
    go test -v ./... || { log_err "tests failed"; return 1; }
    log_info "tests passed!"
}

run_local() {
    log_info "running local..."
    go run ./cmd/yale -local || { log_err "local run failed"; return 1; }
    log_info "local run passed!"
}

run() {
  local -r build_cmd="$cmd"
  case "$build_cmd" in
    tests) run_tests || return 1;;
    local) run_local || return 1;;
    *) log_err "unknown build command: $build_cmd"; return 1 ;;
  esac
}

main() {
  parse_opts "$@" || exit 1;
  check_required_tools "${required_tools[@]}" || exit 1;
  run || exit 1;
}

main "$@"
